7e5f294a85c5b6899e50b5f3295d16eeb78f685d

prediction = []
test_accs = []
with torch.no_grad():
    for data, labels in test_loader:
        test_preds = [] 
        for model_best in models:
            test_preds.append(model_best(data.to(device)).cpu().data.numpy())
        test_preds = sum(test_preds)
        print(test_preds)
        test_label = np.argmax(test_preds, axis=1)
        test_preds = torch.from_numpy(test_preds).to(device)
        
        acc = (test_preds.argmax(dim=-1) == labels.to(device)).float().mean()
        test_accs.append(acc)
        prediction += test_label.squeeze().tolist()
test_acc = sum(test_accs) / len(test_accs)

print(f"Test accurary: {test_acc}")

device = "cuda" if torch.cuda.is_available() else "cpu"

test_fold = k_fold

models = []
for i in range(test_fold):
    fold = i + 1
    model_best = Classifier(Residual_Block, num_layers).to(device)
    model_best.load_state_dict(torch.load(f"Fold_{fold}_best.ckpt"))
    model_best.eval()
    models.append(model_best)

prediction = []
test_accs = []
with torch.no_grad():
    for data, labels in test_loader:
        test_preds = [] 
        for model_best in models:
            test_preds.append(model_best(data.to(device)).cpu().data.numpy())
#         print(test_preds[0].shape)
        
        preds = []
        for i in range(test_fold):
            temp_pred = np.argmax(test_preds[i], axis=1).tolist()
            preds.append(temp_pred)
        pred = list(zip(*preds))
        pred = np.array(pred)
        choice = np.apply_along_axis(lambda x: np.bincount(x).argmax(), axis=1, arr=pred)

        test_preds = torch.from_numpy(choice).to(device)
        acc = (test_preds == labels.to(device)).float().mean()
        test_accs.append(acc)
        prediction += test_label.squeeze().tolist()
test_acc = sum(test_accs) / len(test_accs)

